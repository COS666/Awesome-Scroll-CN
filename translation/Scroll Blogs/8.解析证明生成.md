# 解析证明生成

*作者：Andy Arditi ( [@_andyrdt](https://twitter.com/_andyrdt) ) 和 Ye Zhang ( [@yezhang1998](https://twitter.com/yezhang1998) ) 。*

*致谢：感谢 Yi Sun、Han Jian 和 Ying Tong Lai 的反馈和审阅。*

*翻译：Junwei Fang*

## 介绍

零知识证明 (以下简称ZKP) 最近在加密社区引起了极大的轰动。随着 ZKP 在过去几年变得越来越可行，其带来了新的技术可能性，现在被视为隐私和扩容问题的主要解决方案。

尽管潜力巨大，但现如今大多数 ZKP 系统都面临着一个主要限制：证明生成缓慢且成本高昂。

这种限制通常被用来批评ZKP技术，这是没问题的（至少目前如此）。生成某些程序正确执行的证明，比执行原始程序需要的计算代价高好几个数量级。*因此生成复杂程序证明的成本变得非常高昂（有时甚至令人望而却步*）。这种高成本限制了原本可以切实应用ZKP技术的领域。

在本文中，我们的目标是了解*为什么*证明生成成本如此高昂。为此，我们需要从技术层面解析证明生成的工作原理，并准确了解其中涉及哪些类型的计算。一旦了解了证明生成的内部工作原理，我们就可以探索各种如何加速它的想法。

## 工作示例：Square-Fibonacci

为了演示证明生成的过程，我们将在整篇文章中使用一个工作示例。

我们定义Square-Fibonacci数列[[1\]](https://scroll.io/blog/proofGeneration#fn1)，它是Fibonacci数列的变体：

- 令 $f_0=1,f_1=1$
- 对于$i>2$，定义$f_i:={(f_{i-2})}^2+{(f_{i-1})}^2\ mod\ q $ 
	- 其中$q$是一个大质数。我们利用模来限定每个元素的大小，这样就可以用预先设定的位数来表示它们

令n是一些非常大的整数。为方便起见，我们假设$n$是2的幂值。令$k$是第$n$个Square-Fibonacci数。

**我们的目标**：生成可有效验证的证明$π$ ，证实$k$确实是个第$n$个Square-Fibonacci数（即$f_n=k$）。

验证者可以单纯地通过计算$f_2$， 接着$f_3$，随后$f_4$，依此类推直到算出$f_n$，然后检查$f_n$是否等于$k$来检验上述的声明。然而，这需要的计算步骤非常多（记住$n$非常大）。

理想情况下我们想要证明$π$是“可有效验证的” — 即相较于重新计算$f_n$，验证者应该能够明显更快更有效地验证证明。

## 基于 Plonk 的证明生成概述

在这篇文章中，我们将专注于解释基于 Plonk 的证明系统。虽然存在其他证明系统，但研究这一类特定的系统将使人们对证明生成过程有一个大致的了解。

自最初于 2019 年提出[Plonk](https://eprint.iacr.org/2019/953.pdf)证明系统以来，已经开发出了许多衍生和变体。基于 Plonk 的一系列证明系统已经获得了广泛采用，应用于许多ZKP项目。

在 Scroll，我们使用的是“ [Halo 2](https://electriccoin.co/blog/ecc-releases-code-for-halo-2/) ”，这是一个基于 Plonk 的证明系统，由我们在[Zcash](https://z.cash/)的好朋友构建和维护。我们[修改了Halo 2](https://github.com/privacy-scaling-explorations/halo2)以使用 KZG 作为其多项式承诺方案（而不是其默认方案[IPA](https://dankradfeist.de/ethereum/2021/07/27/inner-product-arguments.html)），以实现更高效的链上证明验证。

### 证明生成的阶段

从高阶视角看，证明生成包含三个阶段：

- 第1阶段：写出“见证 (witness) ”
	- “见证”（有时也称为“踪迹 (trace)”）指的是一些表明声明是正确的数据
		- 例如，在 Square-Fibonacci 示例中，我们会在表格中填入每一步的计算，每行填写一步。
		- 第一行将包含$[f_0, f_1, f_2]$， 其中$f_2 = (f_0)^2 + (f_1)^2$。第二行将包含$[f_1, f_2, f_3]$， 其中$f_3 = (f_1)^2 + (f_2)^2$，以此类推，直到最后一行包含$[f_{n-2}, f_{n-1}, f_{n}]$
- 第2阶段 ：承诺见证
	- 承诺见证涉及输出见证的一些简洁的表示，这意味着*压缩了*见证数据。
	- 在此步骤中使用多项式承诺方案，使我们能够利用简洁的承诺来证明原始见证的特定属性。
- 第3阶段：证明见证是正确的
	- 第1阶段中生成的见证必须遵循特定属性才是有效的。
		- 例如，在 Square-Fibonacci 示例中，必须保证在每一行满足$f_i={(f_{i-2})}^2+{(f_{i-1})}^2$。
	- 生成原始见证满足这些属性的简洁证明。证明的验证不需要访问原始的见证表 — 只需参考第2阶段中生成的简洁承诺即可执行验证。

我们将更深入地探究这三个阶段中的每个阶段，并探索每个阶段所需的计算。
然而在此之前，我们首先需要简要回顾一下有关多项式的一些概念。

## 多项式预备知识

### 表示形式

$(n-1)$次多项式$P(x) = \sum_{i=0}^{n-1} p_i x^i$可以用如下两种方式表示：

1. **系数形式**
	- $P(x)$可以表示成它的$n$个系数的元组: $[p_0,p_1,...,p_{n-1}]$
2. **求值形式**
	- $P(x)$可以表示为它的$n$个不同的求值: $[P(x_0),P(x_1),...,P(x_{n-1})]$
		- 多项式在$\{ x_0, x_1,..., x_{n-1}\}$上求值，该集合称为“求值域”

从系数形式到求值形式的转换称为“傅立叶变换”，反方向转换称为“逆傅立叶变换”。

这两个转换中都可以用简单的方法实现，计算复杂度为$O(n^2)$。从系数形式出发，我们可以简单地对多项式在求值域的每个点求值。从求值形式，我们可以使用[拉格朗日插值法](https://en.wikipedia.org/wiki/Lagrange_polynomial#Definition)来获得唯一的通过*$n$*个点的$(n-1)$次多项式。

因为我们需要处理非常高阶的多项式，因此我们希望这些变换更加高效。这就是*快速*傅立叶变换的用武之地。

### 快速傅立叶变换 (FFT)

可以通过添加一些额外的结构来提高转换的效率。证明系统通常只考虑[有限域](https://en.wikipedia.org/wiki/Finite_field)上的多项式，因此我们限制每个系数$p_i$和每个求值点$x_i$都是一个有限域$\mathbb{F}$中的元素。此外，我们将限制求值域$(x_i)$是$\mathbb{F}$的一个乘法子群。换句话说，对于元素$\omega \in \mathbb{F}$阶数为$n$的求值域可以写成$\{\omega^0, \omega^1, \ldots, \omega^{n-1}\}$ （即$\omega^n=1\ mod \ q$）。集合中的元素被称为“单位根”，因为它们中的任何一个的$n$次幂都等于1，即“单位”元素。

这种约束求值域的附加结构可以实现一些很好的数学上的对称性，我们可以利用这些对称性来提高转换效率。**快速傅里叶变换 (FFT)**算法利用了这些对称性在$O(n log_n)$的复杂度内实现了傅里叶变换。 **逆快速傅立叶变换 (iFFT)**算法类似地实现了傅立叶逆变换。

如需更深入地了解快速傅立叶变换，请查看 Vitalik 的这篇[博客](https://vitalik.ca/general/2019/05/12/fft.html)。

完成这些准备工作后，我们可以继续解析第1阶段。

## 第1阶段：填写见证表

### 见证表

**见证表**是一个二维矩阵，其中记录了“见证”（或“踪迹”）。除了见证之外，见证表还包括其他有助于证明见证是正确的值。见证表中的每个单元格都是一个大有限域$\mathbb{F}_q$的一个元素。

对于我们的工作示例，见证表可能如下所示：
![img](https://scroll.io/img/blog/proofGeneration/tracetable_1.png)

标记为***A, B, C***的前三列表示“见证数据”（也称为“隐私输入(Private Input)”）。每行列出三个连续的Square-Fibonacci数。第$i$行$(f_i,f_{i+1},f_{i+2})$可以视为第$(i+2)$个Square-Fibonacci数的见证，因为它明确地显示了用于计算它的前两个值。

标记为***S***的列被称为“选择器(selector)”列。它表明该行的元素满足某种数学关系或“自定义逻辑门(custom gate)”。在我们的示例中，***S***列的“1”表明该行的前三个元素$(a,b,c)$必须满足$c = a^2 + b^2 \mod q$。***S***列的“0”表明不需要满足此自定义逻辑门。请注意，在最后一行中，见证数据为空，因此选择器已关闭。为了方便，我们插入这个空行，这样表格的高度就变成了n。

标记为***P***的列被称为“公共输入(Public Input)”列。此列包括公开的电路输入。在我们的示例中，Square-Fibonacci数列中的前两个值$f_0, f_1$是众所周知的，而*k*是要证明的声明中的值。

### 见证生成

实际填写见证表的过程称为“见证生成”。

此过程需要遍历表中的每个单元格并填写相应的值。通常，单元格的值要么从外部数据源复制而来，要么根据边上的单元格计算得出。后者需要对$\mathbb{F}_q$中的元素进行算术运算，因为见证表的每个单元格都是这个大有限域中的一个元素。

大有限域元素的算术计算比原生类型（例如`int`或`long`）成本更加高昂。字段元素通常需要大约256 位来表示，这比现代CPU的[字长](https://en.wikipedia.org/wiki/Word_(computer_architecture))要大得多。除了需要计算所有值的取模之外，还必须将每个元素的表示拆分为多个字节, 增加了每一步算术运算的计算开销。

在我们的工作示例中，填写见证表涉及计算每一列的$f_{i+2}=(f_i)^2+(f_{i+1})^2$，需要$\mathbb{F}_q$上的乘法和加法。

对于这个特定的示例（计算第$n$个Square-Fibonacci数），见证生成所需的总计算量与执行原始计算所需的总计算量基本相同。见证的每一行与原始计算的每一步一一对应。

然而，对于更复杂的示例[[2\]](https://scroll.io/blog/proofGeneration#fn2)，见证生成所需的计算量通常比原始计算大得多。复杂计算的每个单独的步骤可能需要由*许多*见证行表示（在某些情况下超过1000行）。这种更复杂的表示或“算术化”通常会导致见证表的大小显著增加。

总的来说，如果见证表非常大并且有很多条目要计算，则见证生成所需的时间和计算量代价会非常大。

### 附加处理

一旦见证数据（或“隐私输入”）被填写并提交，就会对见证表进行一些额外的处理。

辅助列（也称为“虚拟列”）是为便于证明见证有效性而生成的额外列。在某些类型的约束中需要这些辅助列。

其中一个约束是“线路约束(wiring constraint)”。此约束强制见证表中的某些单元格采用相同的值。在 Square-Fibonacci的见证表中，我们需要如下约束来强制每一行延续前一行开始顺序执行：对于连续的两行$[a_i,b_i,c_i]$和$[a_{i+1},b_{i+1},c_{i+1}]$，我们强制要求$a_{i+1}=b_i$和$b_{i+1}=c_i$。

从高阶视角[[3\]](https://scroll.io/blog/proofGeneration#fn3)中，“累加器多项式”是根据见证数据计算出来的中间形式，然后会以求值的形式存储在额外的辅助列***Z***中。因此证明线路约束成立简化为了证明***Z***列的某些约束及其与其他见证列的关系成立。

另一种需要辅助列的约束是查找表 (Lookup Table)。[Plookup](https://eprint.iacr.org/2020/315.pdf)在2020年被首次提出，查找表允许进行高效的集合归属检验。用于生成查找表的辅助列所需的计算，可能涉及除算术运算之外的排序。

请注意，辅助列在完全生成并承诺见证数据后才会计算。辅助列值不仅取决于见证数据，还取决于一些额外的随机性。这种随机性使用[Fiat-Shamir heuristic](https://en.wikipedia.org/wiki/Fiat–Shamir_heuristic)方案计算，并依赖于见证数据的承诺。

### 第1阶段成本汇总

- 将见证数据输入见证表
	- 遍历并填充见证表中的所有见证单元格
	- 计算见证值需要大有限域上的计算
- 为线路和查找表约束生成辅助列
	- 需要额外的大有限域上的计算（在查找表中还需要排序）

## 第 2 阶段：承诺见证表

### 将见证表列转义为多项式

考虑见证表中的***A***列。该列与所有其他列一样，只是一个长度为*n*的有限域元素的向量。我们可以把这个向量看成是一个唯一的$n-1$次多项式*$A(x)$*的求值形式：***A***中的第$i$个元素对应$A(ω^i)$的求值。 此处，$\omega \in \mathbb{F}_q$正如“多项式预备知识”部分中所定义 — 它的阶数为*$n$*。

如下是我们的见证表（包括辅助列***Z***) 转义为列多项式的求值形式后的样子：
![img](https://scroll.io/img/blog/proofGeneration/tracetable_2.png)

### 承诺列多项式

现在我们看到了如何将列转义为多项式，我们可以使用多项式承诺方案来承诺它们中的每一列。

这允许我们将每一列“压缩”成一个简短的表示形式。对所有列执行此操作会生成整个见证表的简洁表示。

使用多项式承诺方案还允许我们生成求值证明 — 证明者可以说服验证者承诺的多项式通过特定点，而无需揭露整个多项式。

### 计算 KZG 承诺

本小节将简要概述计算每列的KZG 承诺所需的数学计算。如需更完整的数学处理过程，请参阅Dankrad Feist关于[KZG](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)和[多项式承诺多值证明](https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html)的博客（在后一篇文章中，请参考标题为“求值形式”和“拉格朗日多项式”的章节）。

首先是一些符号：令$[r]_1$表示$r ⋅ g$， 其中$g$是椭圆曲线群$\mathbb{G}$的生成元

令$\tau \in \mathbb{F}_q$表示在KZG初始化可信设置中使用的秘密值。我们可以将KZG可信设置的输出写为$([\tau^0]_1, [\tau^1]_1, [\tau^2]_1\ldots, [\tau^l]_1)$。注意$l$是承诺的多项式的次数上限。

假设$A(x)$是我们要承诺的列多项式。要为此多项式计算的 KZG 承诺是$[A(\tau)]_1$。

如果我们有$A(x)$的系数形式，$A^{(i)}$表示第$i$个系数，我们可以计算承诺值如下：
$$
[A(\tau)]_1 = \displaystyle\sum_{i=0}^{n-1} A^{(i)}\cdot [\tau^i]_1
$$
但是，这需要将$A(x)$从求值形式转换成系数形式。

事实上有一种高效计算的方法可以直接从$A(x)$的求值形式计算得出$[A(\tau)]_1$。我们可以通过利用[拉格朗日基多项式](https://en.wikipedia.org/wiki/Lagrange_polynomial)来实现这一点：

- 对于多项式在求值域$\{ x_0, x_1, \ldots, x_{n-1} \}$上求值
	- 定义*n*个“拉格朗日基多项式”：
		- 对于$0 \leq i < n$
			- $\ell_{i}(x):= \prod_{j \neq i} \frac{x-x_j}{x_i - x_j}$
	- 然后我们可以表示为$A(x) = \sum_{i=0}^{n-1} A(x_i) \cdot \ell_i(x)$
		- 特别的，$A(\tau) = \sum_{i=0}^{n-1} A(x_i) \cdot \ell_i(\tau)$
		- 因此，我们可以表示为
			- $[A(\tau)]_1 = [\sum_{i=0}^{n-1} A(x_i) \cdot \ell_i(\tau)]_1 = \sum_{i=0}^{n-1 } A(x_i) \cdot [\ell_i(\tau)]_1$

在我们的示例中，求值域是$\{ x_0, x_1, \ldots, x_{n-1} \} = \{ \omega^0, \omega^1, \ldots, \omega^{n-1} \}$，因此每个基础多项式都可以预先计算为$\ell_i(x) = \prod_{j \neq i} \frac{x - \omega^j}{\omega^i - \omega^j}$。此外，由于每次都使用相同的秘密值$\tau$，每个$[\ell_i(\tau)]_1$也可以预先计算：
$$
[\ell_i(\tau)]_1 = \left[ \sum_{j=0}^{n-1} \ell_i^{(j)}\cdot \tau^j \right]_1= \sum_{j= 0}^{n-1} \ell_i^{(j)} \cdot [\tau^j]_1
$$
有了预先计算好的每一个$[\ell_i(\tau)]_1$，在证明生成时承诺***A***列只需要进行以下计算：
$$
[A(\tau)]_1 = \sum_{i=0}^{n-1} A(\omega^i) \cdot [\ell_i(\tau)]_1
$$
请注意，每个$A(ω^i)$是$\mathbb{F}_q$中的一个元素（见证表中***A***列的第*i*个元素）。每个$[\ell_i(\tau)]_1$个的是椭圆曲线群$\mathbb{G}_1$中的一个元素. 因此，这里的计算可以看作标量向量和群元素向量之间的点积。

### 多标量乘法 (MSM)

通常，计算标量向量与群元素向量之间的点积的问题称为“**多标量乘法**”或简称“ **MSM** ”。

尽管听起来很简单，但 MSM 的计算并不简单，因为它们涉及对群元素的算术运算。这种群元素的算术运算通常比我们在第1阶段遇到的大有限域算术成本更高。在我们的例子中，我们使用的是椭圆曲线群，其中两个元素的单步加法需要许多有限域上的算术运算。

有关 MSM 的更完整介绍及其实现的一些思路，请参考Entropy1729的这篇[精彩文章](https://www.entropy1729.com/multiscalar-multiplication/)。

### 第2阶段成本汇总

- 承诺见证表的每一列（实际列和辅助列）
	- 对于长度为$n$的每一列, 可以通过来计算规模为$n$的MSM得到它的 KZG 承诺

## 第 3 阶段：证明见证表的正确性

至此，我们已经填写了整个见证表，并承诺了它的每一列（包括辅助列）。

现在剩下要做的就是证明原始见证表是有效的。

原始见证表有效意味着什么？这意味着满足特定的约束。在我们的工作示例中，我们有以下约束：

- Square-Fibonacci 约束：
	- 每个选定的行$i$必须满足: $c_i = a_i^2 + b_i^2 \mod q$
- 线路约束：
	- 对于连续行: $ [a_i, b_i, c_i]$和$[a_{i+1}, b_{i+1}, c_{i+1}]$， 我们要求$a_{i+1} = b_i$和$b_{i+1} = c_i$
- 公共输入约束：
	- 第一行必须以前两个Square-Fibonacci 数字开头，它们写在公共输入列的前两行中：$a_0 = p_0, b_0 = p_1$
	- 对应的第*n*个Square-Fibonacci数的单元格必须匹配声明的结果值，该值写在公共输入列的第三行：$c_{n-2} = p_2$

通过将每一列视为求值形式的多项式（即将$a_i$视为$A(ω^i)$，上面的每一个约束都可以用列多项式之间的一个或多个关系式来表示。

例如，Square-Fibonacci 约束可以表示为列多项式***A、B、C、S***之间的如下关系式：
$$
对于所有x \in \{\omega^0, \omega^1, \ldots, \omega^{n-1} \}, S(x) \cdot (A(x)^2 + B(x)^2 - C(x)) = 0
$$
为了表示方便，我们将左侧多项式表示为
$$
\phi_0(x) := S(x) \cdot (A(x)^2 + B(x)^2 - C(x))
$$
因此我们所有的约束都可以用如下形式表示：
$$
\text{ 对于所有 } x \in \{ \omega^0, \omega^1, \ldots, \omega^{n-1}\},\ \phi_i(x) = 0
$$

### 组合约束

一般来说，当我们有$m$个在求值域上求值均为0的约束多项式$\phi_0(x), \phi_1(x), \ldots, \phi_{m-1}(x)$时，我们可以将它们一起批处理以获得单个约束多项式$\phi(x)$（称为元约束多项式）必须在求值域上求值为 0。我们通过采样一个随机字段元素$\gamma \in \mathbb{F}_q$来实现这一点，然后得到各个约束的随机线性组合：
$$
\begin{align*}
\phi(x) := \gamma^0 \cdot \phi_0(x) + \gamma^1 \cdot \phi_1(x) + \ldots + \gamma^{m-1} \cdot \phi_{m-1 }(x) 
\end{align*}
$$
如果所有单独的约束多项式在求值域上的计算结果为0，则元约束多项式$\phi(x)$也一定为0。如果任何一个单独的约束多项式在求值域上的某个点求值结果不为0，那么几乎可以肯定的是$\phi(x)$在那个点求值也不会为 0[[4]](https://scroll.io/blog/proofGeneration#fn4)。因此，足以证明$\phi(x)$在整个求值域上求值为 0。
$$
每一行都满足约束条件 \iff \text{ 对于所有 } 0 \leq i < n,\ \!\! {_p} \,\, \phi(\omega^i)=0
$$
我们如何证明右边的声明呢？我们当然可以计算每个列多项式在$n$个求值域上点证明。这将使我们能够在每个相关点上计算$\phi(x)$。但这会导致证明规模很大——我们需要提供每列多项式的*$n$*个求值证明。

事实证明，我们使用每个列多项式的一个求值证明就可以来证明这样的约束。

### 商多项式

我们需要证明见证表的每一行都满足元约束$\phi(x)$。这个声明*不*容易直接证明。但事实证明，我们可以推导出[[5]](https://scroll.io/blog/proofGeneration#fn5)一个等价的[[6]](https://scroll.io/blog/proofGeneration#fn6)声明，而它很容易证明：
$$
\begin{aligned} \text{每一行都满足约束条件} & \iff  \text{ 对所有 } 0 \leq i < n,\ \!\! {_p} \,\, \phi(\omega^i) = 0\\ & \iff \text{ 对于所有 } 0 \leq i < n, (x- \omega^i) | \phi(x) \\ & \iff \prod_{i=0}^{n-1} (x - \omega^i) | \phi(x)\\ & \iff (x^n -1) | \phi(x)\\ & \iff 存在 Q(x) \text{ 满足 } \phi(x) = Q(x) \cdot (x^n - 1) \end{aligned}
$$
所以，如果我们想证明所有约束在每一行均成立，那么就相当于证明存在一个多项式$Q(x)$满足上述的性质。该多项式通常称为“商多项式”。

### 计算并承诺商多项式

商多项式可以计算为
$$
Q(x) := \frac{\phi(x)}{x^n - 1} = \frac{\gamma^0 \phi_0(x) + \gamma^1 \phi_1(x) + \ldots + \gamma^{m-1}\phi_{m-1}(x)}{x^n -1}
$$
虽然商多项式在理论上很容易表示，但实际计算中它往往是最复杂和计算成本最高的步骤之一。

让我们考虑一下$Q(x)$的阶数. 其阶数等于具有最高次数的约束多项式的阶数减去*n*. 在我们的示例中，Square-Fibonacci 约束：$\phi_0(x) = S(x) \cdot (A(x)^2 + B(x)^2 - C(x))$，最高次数为$3n-3$, 所以相应的商多项式$Q(x)$的次数为$2n-3$。为了完整表示这样的多项式，我们至少需要$2n-2$个求值点。

所以让我们把它变成一个更规整的整数并使用*2n*个求值点。我们之前的求值域将不起作用 — ω的阶数为$n$，所以集合$\{ \omega^i |  \in \mathbb{N} \}$的大小为$n$。因此我们需要选择一些阶数为$2n$的其他元素$\beta \in \mathbb{F}_q$。 然后我们可以在求值域$\{ \beta^0, \beta^1, \ldots, \beta^{2n-1}\}$上对$Q(x)$求值，获得我们所需的$2n$个求值点。

以下是最高效执行此操作所需的步骤：

- 对于每列多项式，将求值形式转换为系数形式
	- 每个变换都可以使用 iFFT，在$O(n\ log_n)$复杂度内实现
- 对于每个列多项式的系数形式，生成$2n$ 个求值结果
	- 每个变换都可以使用 FFT在，在$O( 2n\ log\ 2n ) = O ( n\ log\ n)$复杂度内实现 
- 利用*2n*个列多项式的求值结果，我们可以计算$Q(x)$的2n个求值结果
	- 这只需要根据商多项式的公式进行场运算

有了$Q(x)$的求值形式中，我们现在可以按照我们承诺列多项式的方案来计算它的承诺：
$$
[Q(\tau)]_1 = \sum_{i=0}^{2n-1} Q(\beta^i) \cdot [\ell_i'(\tau)]_1
$$
但是请注意，由于$Q(x)$比列多项式的阶数更高，我们需要使用不同的拉格朗日基，比之前使用的基大。虽然可以预先计算这个更大的拉格朗日基并使用它来计算承诺，但它需要更大的KZG可信设置 — 可信设置的规模必须超过商多项式的次数。

实际实现中，我们使用了一个技巧，这样我们只需要承诺阶数小于n的多项式。我们首先使用规模为$2n$的iFFT，将$Q(x)$转换成系数形式。然后，我们将$Q(x)$拆分成两个较小的多项式$Q_{lo}(x), Q_{hi}(x)$，这样$Q(x) = Q_{lo}(x) + x^n \cdot Q_{hi}(x)$。这两个较小的多项式阶数均小于$n$，因此每一个都可以使用规模为$n$的MSM来生成承诺。

因此，一旦计算商多项式得到系数形式，拆分和承诺将需要一个规模为$2n$的iFFT和2个规模为*$n$*的MSM。

请注意，子多项式的数量取决于商多项式的次数 — 如果商多项式次数为$3n$，我们需要将它分成3个子多项式。

### 证明商多项式的存在

至此，证明者已经承诺了见证表中的所有列多项式，并且还承诺了商多项式。证明者现在需要证明商多项式确实存在并且计算正确。请记住，如果此处成立，那么所有的每行约束都成立，因此见证表是有效的。

这可以通过以下步骤来实现：

1. 采样一个随机点$\alpha \in \mathbb{F}_q$
2. 在点$\alpha$为所有列多项式和该点的商多项式生成并输出KZG评估证明\[[7\]](https://scroll.io/blog/proofGeneration#fn7)
	- 为了生成多项式求值$A(\alpha) = z$的 KZG 证明，我们计算并输出$\left[ \frac{A(\tau) - z}{(\tau - \alpha)}\right]_1$
	- 与 KZG 承诺类似，通过MSM计算而来
		- 每个列多项式需要1个规模为*n*的MSM
		- 商多项式需要2个规模为*n*的MSM

### 验证商多项式

验证者收到证明并且必须检验它是否正确。完整的证明包括：

- 对每一列（包括辅助列）和商多项式的承诺
- 每个列多项式和商多项式在点*α*处的求值证明

验证者可以如下检查证明：

1. 验证每个求值证明是否正确
2. 验证商多项式公式在求值点*α*处是否成立:

$$
Q(\alpha) = \frac{\phi(\alpha)}{\alpha^n - 1} = \frac{\gamma^0 \phi_0(\alpha)+\gamma^1\phi_1(\alpha) + \ldots + \gamma^{m-1}\phi_{m-1}(\alpha) }{\alpha^n -1}
$$

如果步骤 2 中的等式在*α*点处成立，那么（几乎可以肯定）它在所有点上都成立，因为*α*是随机取样的。[[8\]](https://scroll.io/blog/proofGeneration#fn8)

每个求值证明验证都需要计算一个[椭圆曲线配对](https://vitalik.ca/general/2017/01/14/exploring_ecp.html)。验证商多项式公式需要一些有限域算法（计算方程的右侧）。总之，与证明生成所需的计算相比，验证所需的计算是轻量化的，并且通常能够在链上高效地执行。

### 第3阶段成本汇总

- 计算求值表中的商多项式
	- 通过规模为$n$的iFFT计算将每列多项式转换为系数形式
	- 通过规模为$2n$的FFT计算将每列多项式转换为扩展的求值形式
	- 使用每列多项式的求值形式，计算商多项式在$2n$个点中的每一个点的求值
- 承诺商多项式
	- 通过规模为$2n$的iFFT计算拆分多项式
	- 承诺每个拆分后的多项式，总共需要 2 个规模为*$n$*的MSM计算
- 为每个多项式生成随机点α处求值的求值证明
	- 每个列多项式需要一个规模为$n$的MSM计算
	- （拆分）商多项式需要 2 个规模为$n$的MSM计算

请注意，FFT/iFFT 的规模和 MSM 的数量取决于商多项式的阶数，而商多项式又取决于最高阶多项式的约束。在我们的例子中，最高阶的多项式约束大约为$3n$，推导出商多项式的阶数大约为$2n$.

## 结论

### 回顾

让我们快速回顾一下与证明生成相关的成本：

- 第 1 阶段：填写见证表
	- 填写见证数据需要在一个大的有限域上进行算术运算
	- 见证表通常非常大，因为在将复杂计算转换为表格/电路形式时存在爆炸系数
	- 辅助列需要额外的算术运算和排序
- 第 2 阶段：承诺见证表
	- 承诺每一列都需要一个规模为$n$的MSM计算
- 第 3 阶段：证明见证表的正确性
	- 计算商多项式的求值形式需要
		- 每列的规模为$n$的iFFT计算
		- 每列的规模为$2n$的FFT计算
		- 大有限域上的算术运算
	- 承诺商多项式需要
		- 规模为$2n$的iFFT计算转换为求值形式
		- 2个规模为*$n$*的MSM计算，每个拆分后的多项式1个
	- 生成 KZG 求值证明需要
		- 每列规模为$n$的MSM计算
		- 拆分后的商多项式的2个规模为$n$的MSM计算

从这个结论中可以清楚地看出，第 2 阶段和第 3 阶段由计算代价较大的MSM、FFT 和 iFFT算法主导。同样明确的是，所有计算步骤随着$n$增加而增加，包括第 1 阶段的见证生成计算。

### 加速之路

有了对证明生成中的计算瓶颈的新的认识，我们可以开始思考如何加速整个过程。整个社区都在积极寻求许多加速方法。下面列出了加速发展的四种主要途径：

**1. 重型计算的硬件加速**

我们已经看到，重型计算（例如 MSM、FFT 和 iFFT）构成了证明生成所需的总计算量的很大一部分。这些算法往往在 CPU 上运行缓慢，但可以通过在 GPU、FPGA 或 ASIC 上运行来大大加速。研究如何最好地利用专用硬件上运行这些算法是一个非常活跃的研究领域。

**2.减少见证表的行数**

我们还看到，几乎所有涉及证明生成的计算都与见证表中的行数n有关（当见证表被称为电路时，也叫做“门数”）。如何使用最少的行数表示某些复杂的计算，是一个会显著提升效率的研究领域。

**3. 并行化和流水线化**

许多证明系统，包括我们在此研究的证明系统，自身都有并行化的可能性。例如，在第2阶段承诺列多项式中，可以并行计算每个列的承诺。更进一步，承诺每个见证列的MSM可以同见证列生成同时计算。并行化和流水线计算可以显著加快整个过程。

**4. 升级的证明系统**

本文阐述了一个特定的证明系统的计算要求。而这只是众多证明系统中的一个 — 理论上的证明系统设计还有巨大升级空间，每个证明系统都有自己的一套计算要求和取舍。现有的研究正在积极探索设计上的可能性，设计出可以减少或消除计算瓶颈的理论架构。



1. Square-Fibonacci的例子是受到[Starkware](https://starkware.co/stark-101/)的教程启发。

2. 例如，如果我们的见证表元素对p取模，而不是同Square-Fibonacci问题中一样对*q*取模，那么每一步运算都将涉及[非原生场运算](https://hackmd.io/@arielg/B13JoihA8)(non-native field arithmetic)（即在$\mathbb{F}_p$上计算$\mathbb{F}_q$的场运算 *q ≠ p*)。每个计算的表示将发散到多行和多个约束中。[↩︎](https://scroll.io/blog/proofGeneration#fnref2)

3. 为了更深入地了解 Plonk 中的线路约束，推荐以下资源：Vitalik 关于 Plonk 的[文章](https://vitalik.ca/general/2019/09/22/plonk.html)（请参阅“复制约束”部分）、Aztec有关算术化的[说明](https://hackmd.io/@aztec-network/plonk-arithmetiization-air)以及 Ariel Gabizon有关多重集检验的[说明。](https://hackmd.io/@arielg/ByFgSDA7D)[↩︎](https://scroll.io/blog/proofGeneration#fnref3)

4. 这是从[Schwartz-Zippel 引理](https://en.wikipedia.org/wiki/Schwartz–Zippel_lemma)得出的。[↩︎](https://scroll.io/blog/proofGeneration#fnref4)

5. 第二行推导自[多项式余数定理](https://en.wikipedia.org/wiki/Polynomial_remainder_theorem)。第四行是从如下的性质得出

	$\prod_{i=0}^{n-1} (x-\omega^i) = (x^n -1)$. [↩︎](https://scroll.io/blog/proofGeneration#fnref5)

6. 从技术上讲，这些声明在逻辑上并不等价。它们在概率上是等价的（我们表示为“ ⟺*p* ”），因为第一步依赖于 Schwartz-Zippel 引理。[↩︎](https://scroll.io/blog/proofGeneration#fnref6)

7. 请参阅 Dankrad Feist 的[帖子](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)或 Alin Tomescu 的[注释](https://alinush.github.io/2020/05/06/kzg-polynomial-commitments.html#evaluation-proofs)，以温习如何生成KZG求值证明。[↩︎](https://scroll.io/blog/proofGeneration#fnref7)

8. 这同样遵循 Schwartz-Zippel 引理。[↩︎](https://scroll.io/blog/proofGeneration#fnref8)